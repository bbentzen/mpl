/-
Copyright (c) 2017 Bruno Bentzen. All rights reserved.
Released under the Apache License 2.0 (see "License");
Author: Bruno Bentzen
-/

import ..syntax.basic ..syntax.language.basic

/- Kripke models -/

-- W wrld is a n âˆˆ nat s.t. w âˆˆ wrld iff w â‰¤ wrld

definition frame : Type := (nat Ã— (nat â†’ nat â†’ bool))

definition k_model : Type := frame Ã— (nat â†’ nat â†’ bool)

notation `ð“¦` `â¸´` `ð“¡` `â¸´` `ð“¿` := k_model

def true_in_wrld (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) : form â†’ nat â†’ bool
| # p     := Î» w, M.snd w p --nat.rec_on (M.fst.fst) tt (Î» _ _, M.snd w p)
| ~ p     := Î» w, bnot (true_in_wrld p w)
| (p âŠƒ q) := Î» w, (bnot (true_in_wrld p w)) || (true_in_wrld q w) 
| â—» p    := Î» w, 
    nat.rec_on M.fst.fst tt 
    (Î» v IH, IH && ((bnot (M.fst.snd w v)) || (true_in_wrld p v)))

notation M `â¦ƒ`p`â¦„` w := true_in_wrld M p w

def nec_ff_exists_wrld_ff (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (w : nat) (p : form) : 
  ((Mâ¦ƒâ—»pâ¦„w) = ff) â‡’ (âˆƒ v, ((M.fst.snd w v) = tt) âˆ§ ((Mâ¦ƒpâ¦„v) = ff)) := 
begin
  unfold true_in_wrld,
  induction M.fst.fst with v IH,
    simp, simp,
    intro H,
    cases H with H1 H2,
     exact (IH H1),
     exact âŸ¨v, H2âŸ© 
end

def all_wrlds_tt_nec_tt (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (w : nat) (p : form) : 
(âˆ€ v, ((M.fst.snd w v = tt) â†’ (Mâ¦ƒpâ¦„v) = tt)) â‡’ ((Mâ¦ƒâ—»pâ¦„w) = tt)  := 
begin
  intro f,
  apply eq_tt_of_not_eq_ff,
  apply 
    (show Â¬ (âˆƒ v, (_ = tt) âˆ§ (_ = ff)) â‡’ Â¬ (_ = ff) , 
      from Î» f a, f ((nec_ff_exists_wrld_ff M w p) a) ),
    intro g, 
    cases g with v h,
      cases h with h1 h2,
        exact (bool.no_confusion (eq.trans (eq.symm (f v h1)) h2))
end

def nec_impl_to_nec_nec (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
  ((Mâ¦ƒâ—»(p âŠƒ q)â¦„w) = tt) â†’ (Mâ¦ƒâ—»pâ¦„w) = tt â†’ (Mâ¦ƒâ—»qâ¦„w) = tt := 
begin
  unfold true_in_wrld,
  induction M.fst.fst with k IH,
    simp, simp at *,
      intros Hpq Hp,
        cases Hpq with Hpq1 Hpq2,
          cases Hp with Hp1 Hp2,
            apply and.intro,
              exact (IH Hpq1 Hp1),
              cases Hpq2,
                apply or.intro_left,
                  assumption, 
                cases Hp2,
                  apply or.intro_left,
                    assumption,
                  cases Hpq2,
                    exact (bool.no_confusion (eq.trans (eq.symm Hp2) Hpq2)),
                    apply or.intro_right,
                      assumption
end

definition nec_impl_ff_exist_wlrd_ff (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
  ((Mâ¦ƒâ—»(p âŠƒ q)â¦„ w) = ff) â‡’ (âˆƒ k : nat, ((Mâ¦ƒpâ¦„k) = tt) âˆ§ ((Mâ¦ƒqâ¦„k) = ff)) := 
begin
  unfold true_in_wrld,
  induction M.fst.fst with k IH,
    simp, simp,
    intro H,
    cases H with H1 H2,
      exact (IH H1),
      cases H2,
      exact âŸ¨k, H2_rightâŸ©
end

def nec_nec_to_nec_impl_nec (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
  ((Mâ¦ƒâ—»pâ¦„w) = tt) â†’ ((Mâ¦ƒâ—»qâ¦„w) = tt) â†’ ((Mâ¦ƒ(â—»p) âŠƒ (â—»q)â¦„w) = tt) := 
begin
  unfold true_in_wrld,
  induction M.fst.fst with v IH,
    intros H1 H2,
    simp, simp,
    intros H1 H2,
    apply or.intro_right,
      assumption
end

def impl_tt_to_impl (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
   ((Mâ¦ƒpâ¦„w) = tt â†’ (Mâ¦ƒqâ¦„w) = tt) â†’ ((Mâ¦ƒp âŠƒ qâ¦„w) = tt) := 
begin
  unfold true_in_wrld,  
  induction (true_in_wrld M p w),
  repeat {
    induction (true_in_wrld M q w),
    simp, simp,
  }
end

def tt_tt_to_impl (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
   ((Mâ¦ƒpâ¦„w) = tt) â†’ ((Mâ¦ƒqâ¦„w) = tt) â†’ ((Mâ¦ƒp âŠƒ qâ¦„w) = tt) := 
begin
  unfold true_in_wrld,  
  induction (true_in_wrld M p w),
  repeat {
    induction (true_in_wrld M q w),
    simp, simp,
  }
end

def nec_impl_to_nec_impl_nec (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
  ((Mâ¦ƒâ—»(p âŠƒ q)â¦„w) = tt) â†’ ((Mâ¦ƒâ—»pâ¦„w) = tt â†’ (Mâ¦ƒâ—»qâ¦„w) = tt) := 
begin
  unfold true_in_wrld,
  induction M.fst.fst with k IH,
    simp, simp,
    intros H1 H2,
      cases H1,
        cases H2,
          apply and.intro,
            exact (IH H1_left H2_left),
            cases H1_right,
              apply or.intro_left,
                assumption,
                cases H1_right,
                  cases H2_right,
                    apply or.intro_left,
                      assumption,
                      exact (bool.no_confusion (eq.trans (eq.symm H2_right) H1_right)),
                    apply or.intro_right,
                      assumption
end 

/- Soundness -/

inductive stsf (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (p : form) : Type 
| is_true (m : Î  (w : nat),  (M â¦ƒpâ¦„ w) = tt ) : stsf

notation M `âŠ¨â‚–` p := stsf M p

definition wk_sndnss (p : form) (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) :
( Â· âŠ¢â‚– p) â‡’ (M âŠ¨â‚– p) :=
begin
  intro H,
  induction H,
    repeat {
      apply stsf.is_true,
        intros w,
        unfold true_in_wrld,
        induction (true_in_wrld M H_p w), 
          induction (true_in_wrld M H_q w),
            simp, simp,
          induction (true_in_wrld M H_q w),
            simp, simp
    },
          induction (true_in_wrld M H_r w),
            simp, simp,
    
    apply stsf.is_true,
      induction H_ih_dâ‚, 
        induction H_ih_dâ‚‚,
          intros w,
          apply eq.symm,
            exact (
              calc 
                tt  = Mâ¦ƒH_p âŠƒ H_qâ¦„w  : eq.symm (H_ih_dâ‚ w)
                ... = bnot (Mâ¦ƒH_pâ¦„w)  || Mâ¦ƒH_qâ¦„w  : rfl
                ... = ff  || Mâ¦ƒH_qâ¦„w  : eq.substr (H_ih_dâ‚‚ w) rfl
                ... = Mâ¦ƒH_qâ¦„w  : ff_bor _
            ),
    apply stsf.is_true,
      intro w,
      apply impl_tt_to_impl,
        intro H,
        apply impl_tt_to_impl,
          apply nec_impl_to_nec_impl_nec,
            assumption,
    apply stsf.is_true,
      intro w, 
      unfold true_in_wrld,
      induction H_ih,
        induction M.fst.fst with k IH,
          simp, simp,
          apply and.intro,
            exact IH,
            induction ((M.fst).snd w k), 
              simp, simp,
              exact (H_ih k)
end

/- Soundness -/

def ctx.true_in_wrld (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) : ctx â†’ nat â†’ bool
| Â·      := Î» w, tt
| (Î“ â¸´ p) := Î» w, ctx.true_in_wrld Î“ w && Mâ¦ƒpâ¦„w

notation M `â¦ƒ`p`â¦„` w := ctx.true_in_wrld M p w

inductive sem_csq (Î“ : ctx) (p : form) : Type 
| is_true (m : Î  (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (w : nat), (M â¦ƒÎ“â¦„ w) = tt â†’ (M â¦ƒpâ¦„ w) = tt ) : sem_csq

notation Î“ `âŠ¨â‚–` p := sem_csq Î“ p

definition sndnss (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (Î“ : ctx) (p q : form)  :
  (Î“ âŠ¢â‚– p) â‡’ (Î“ âŠ¨â‚– p) :=
begin
  intro H,
  induction H,
    repeat {
      apply sem_csq.is_true,
        intros M w csq,
        unfold true_in_wrld ctx.true_in_wrld,
        induction (true_in_wrld M H_p w), 
          induction (true_in_wrld M H_q w),
            simp, simp,
          induction (true_in_wrld M H_q w),
            simp, simp
    },
          induction (true_in_wrld M H_r w),
            simp, simp,
        
      apply sem_csq.is_true,
      induction H_ih_dâ‚, 
        induction H_ih_dâ‚‚,
        intros M w csq,
          apply eq.symm,
            exact (
              calc 
                tt  = Mâ¦ƒH_p âŠƒ H_qâ¦„w  : eq.symm (H_ih_dâ‚ M w csq)
                ... = bnot (Mâ¦ƒH_pâ¦„w)  || Mâ¦ƒH_qâ¦„w  : rfl
                ... = ff  || Mâ¦ƒH_qâ¦„w  : eq.substr (H_ih_dâ‚‚ M w csq) rfl
                ... = Mâ¦ƒH_qâ¦„w  : ff_bor _
            ),

      apply sem_csq.is_true,
        intros M w csq,
        apply impl_tt_to_impl,
          intro H,
          apply impl_tt_to_impl,
            apply nec_impl_to_nec_impl_nec,
              assumption,

      apply sem_csq.is_true,
        intros M w csq,
        unfold true_in_wrld ctx.true_in_wrld,
      induction H_ih,
        induction M.fst.fst with k IH,
          simp, simp,
          apply and.intro,
            exact IH,
            induction ((M.fst).snd w k), 
              simp, simp,
              exact (H_ih M k rfl)
end

-----------------------------------------------------

def nec_true_allw (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (w : nat) (p q : form) (ne : M.fst.snd w 0 = ff) :
 (âˆƒ v, (v â‰¤ M.fst.fst) âˆ§ ((M.fst.snd w v) = tt) âˆ§ ((Mâ¦ƒpâ¦„v) = ff)) â‡’ ((Mâ¦ƒâ—»pâ¦„w) = ff) :=
begin
  unfold true_in_wrld,    
  induction M.fst.fst with k IH,
    simp, intro H,
    cases H with H1 H2,
      cases H2,
        cases (nat.eq_or_lt_of_le H2_left),
          revert H2_right,
          apply (eq.subst (eq.symm h)),
            intro H,
              cases H,
                exact (bool.no_confusion (eq.trans (eq.symm H_left) ne)),
          apply absurd, -- (absurd not_lt_zero h)        
            exact h,
            exact (not_lt_zero _),
    simp,
    intro H,

end

def nec_true_allw2 (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (w : nat) (p : form) :
((Mâ¦ƒâ—»pâ¦„w) = tt) â‡’ (âˆ€ v, ((M.fst.snd w v) = tt) â†’ ((Mâ¦ƒpâ¦„v) = tt)) :=
begin
  unfold true_in_wrld,    
  induction M.fst.fst with k IH,
  sorry,
--##for succ:
  simp,
  intros H1 v H2,
    cases H1,
      exact (IH H1_left v H2)
end

-------------------------------


-- Hp2 Hpq2

-- (eq.trans (eq.symm (f v h1)) h2)

#check @bool.no_confusion

/--def nec_false_2 (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿)) (w : nat) (p : form) : 
  (âˆƒ v, ((M.fst.snd w v) = tt) âˆ§ ((Mâ¦ƒpâ¦„v) = ff)) â‡’ (Â¬ (Mâ¦ƒâ—»pâ¦„w) = tt) := 
begin
  unfold true_in_wrld,
    intro H1,
    induction H1 with v H1,
    induction M.fst.fst with k IH,
    sorry,
    simp at *,
    intro H2,
      cases H2,
        cases H2,
          exact (bool.no_confusion (eq.trans (eq.symm H2_left) IH)),
        cases H1,
--          exact (bool.no_confusion (eq.trans (eq.symm H2) H1_right)),
end--/

#check bool

definition quasi_K (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) ) (w : nat) (p q : form) : 
  ((Mâ¦ƒâ—»(p âŠƒ q)â¦„ w) = tt) â‡’ ((Mâ¦ƒ(â—»p) âŠƒ (â—»q)â¦„w) = tt) := 
begin
  intro H,
  apply impl_tt_to_impl,
    apply nec_impl_to_nec_impl_nec,
      assumption
end 

variables (M : (ð“¦ â¸´ ð“¡ â¸´ ð“¿) )  (w : nat) (p q : form) --(H : (Mâ¦ƒâ—»(p âŠƒ q)â¦„w) = tt)
#reduce (Mâ¦ƒâ—»pâ¦„w) = tt
#check p & q

-------------


definition bor_to_or {b1 b2 : bool} :
((bnot b1) || b2 = tt) â†’ (b1 = ff âˆ¨ b2 = tt)  :=
begin
  intro p,
  induction b1, simp, simp,
  induction b2, simp, exact (bool.no_confusion p), simp
end

example (b : bool) :
(b = ff âˆ¨ b = tt) â†’ (bnot b || b = tt) :=
begin
  intro w,
  cases w,
    induction b, simp, simp,
    induction b, simp, simp
end


example {A : Type} (a b : A) (f : A â†’ bool) (P : bool â†’ Type) (H : P (f b) â†’ P (f b)) :
  P (f b) :=
begin
  revert H, induction (f b)
end


--end

--------------------------------------------------------------------------

open tactic

meta def contra_false : list expr â†’ tactic unit
| []        := failed
| (H :: Hs) :=
  do t â† infer_type H >>= whnf,
     match ht with
     | `(and %%a %%b) := do sorry
end


#check 

meta def ematch_test (h : name) : tactic unit :=
do ctx â† local_context,
_

#check mk_dec_eq_instance

--meta def trivial_induction {Î“ : ctx} {p : form} (H : prf Î“ p) : tactic expr :=

meta def tri_nat : â„• â†’ tactic expr 
| zero := do z â† zero >>= z
| (succ n) := _

def contssr (p q : form) (Î“ : ctx):
  (Î“ â¸´ p â¸´ p âŠ¢â‚– q) â‡’ (Î“ â¸´ p âŠ¢â‚– q) :=
begin
  intro H,
  trivial_induction
end

/- Is in list nat -/



--set_option pp.notation false

#check deduction

example (p q : form) :
 Â· âŠ¢â‚– â—» p âŠƒ â—» (q âŠƒ p) := 
prf.k (prf.nec prf.ax1))

end mpl

/--

definition is_in_ctx (w : nat) : ctx â†’ Type
| nil := empty
| (v::t) :=
  match (dec_eq_ctx w v) with
  | (is_true H) := unit
  | (is_false H) := empty
  end


 --/
